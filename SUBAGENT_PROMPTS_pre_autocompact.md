# Ready-to-Use Subagent Orchestration Prompts

**Project**: AI Tool Stack Evaluator  
**Approach**: 1 Prompt Per Phase + Autonomous Execution + Strategic Model Usage  
**Usage**: Copy and paste each prompt directly into Claude Code  
**Resource Optimization**: Strategic Opus 4/Sonnet 4 allocation for maximum efficiency

---

## üöÄ Phase 1: Foundation Subagent

**Copy this prompt exactly into Claude Code:**

```
FRAMEWORK-ENHANCED FOUNDATION SUBAGENT - AI TOOL STACK EVALUATOR

<!-- MODEL_DIRECTIVE: Strategic model switching for optimal resource usage -->
@model:sonnet-4

CRITICAL MODEL SWITCHING STRATEGY:
Use @model:opus-4 ONLY for:
- Steps 8-10: Core evaluation algorithm design and optimization
- Complex scoring mechanism development  
- Advanced architectural pattern decisions

Use @model:sonnet-4 for all other tasks:
- Steps 1-7: Project setup, dependencies, file structure
- Steps 11-15: Database implementation, testing, validation
- Documentation and routine implementation

You are an autonomous development subagent implementing Phase 1: Foundation with integrated Anthropic orchestrator-workers pattern and community framework specialization.

PROJECT CONTEXT:
- Building complete AI tool stack evaluation system (web + CLI)
- Located at: /Users/jordaaan/starter-stacks/tools/stack-evaluator
- Must read BUILD_PHASES.md Phase 1 (Steps 1-15) for detailed implementation
- Enhanced with frameworks: Anthropic patterns + wshobson agents + production patterns
- Available community agents: /Users/jordaaan/starter-stacks/.claude/agents/

FRAMEWORK-ENHANCED AUTONOMOUS EXECUTION:

1. **Anthropic Orchestrator-Workers Pattern**:
   - Architecture Worker: System design, database schema (steps 1-5)
   - Implementation Worker: Evaluation engine, scoring logic (steps 6-10)
   - Integration Worker: Testing, validation, documentation (steps 11-15)

2. **Community Agent Integration**:
   - Apply backend-architect patterns for optimal API and database design
   - Use ai-engineer patterns for evaluation algorithm optimization
   - Integrate test-automator patterns for comprehensive validation

3. **Enterprise Quality Standards**:
   - Implement performance monitoring from start
   - Add comprehensive error handling and logging
   - Create production-ready documentation

4. **Model-Aware Execution**:
   - Use Sonnet 4 for Steps 1-7: Setup and infrastructure
   - Switch to @model:opus-4 for Steps 8-10: Algorithm design
   - Return to Sonnet 4 for Steps 11-15: Implementation and testing

AUTONOMOUS EXECUTION WORKFLOW:
Read BUILD_PHASES.md Phase 1 (Steps 1-15), create optimized project structure with framework enhancements, implement evaluation engine with community patterns, comprehensive testing and validation

SUCCESS CRITERIA (Enhanced):
‚úÖ All Phase 1 files per BUILD_PHASES.md + framework enhancements
‚úÖ Code follows Anthropic orchestrator-workers best practices
‚úÖ Database design optimized with backend-architect patterns
‚úÖ Evaluation algorithm enhanced with ai-engineer patterns (Opus 4 quality)
‚úÖ Test coverage follows test-automator comprehensive standards
‚úÖ Performance benchmarks and monitoring integrated
‚úÖ Optimal model usage - Opus 4 reserved for complex algorithm work only

DELIVERABLE: Enterprise-quality evaluation engine with framework-enhanced architecture

BEGIN AUTONOMOUS FRAMEWORK-ENHANCED IMPLEMENTATION NOW.
```

---

## üåê Phase 2: Web Interface Subagent

**Copy this prompt exactly into Claude Code:**

```
FRAMEWORK-ENHANCED WEB INTERFACE SUBAGENT

<!-- MODEL_DIRECTIVE: Sonnet 4 throughout - standard React/UI development -->
@model:sonnet-4

RATIONALE: React component development, Tailwind styling, and standard web interface patterns are well-suited for Sonnet 4. No complex algorithms requiring Opus 4.

You are an autonomous development subagent implementing Phase 2: Web Interface with framework enhancement patterns.

FOUNDATION STATUS: Phase 1 complete - evaluation engine and stack database ready for integration

PROJECT CONTEXT:
- Building Next.js web application with 5-question evaluation flow
- Must integrate with existing evaluation engine from Phase 1
- Enhanced with frontend-developer and performance-engineer patterns
- Target: Production-ready web interface with enterprise quality

FRAMEWORK-ENHANCED AUTONOMOUS EXECUTION:

1. **Frontend-Developer Patterns** (wshobson community agent):
   - React components with accessibility best practices
   - Responsive design with mobile-first approach
   - Performance optimization and Core Web Vitals focus

2. **User Experience Optimization**:
   - Progressive question flow with smart validation
   - Loading states and error handling throughout
   - Intuitive results display with comparison features

3. **Enterprise Quality Standards**:
   - SEO optimization for stack.organizedai.vip discoverability
   - Analytics integration for usage tracking
   - Performance monitoring and optimization

AUTONOMOUS EXECUTION WORKFLOW:
Read BUILD_PHASES.md Phase 2 (Steps 16-35), implement Next.js web interface with framework patterns, integrate evaluation engine, comprehensive testing and optimization

SUCCESS CRITERIA:
‚úÖ Functional web interface with complete evaluation flow
‚úÖ React components following frontend-developer best practices
‚úÖ Responsive design with accessibility compliance
‚úÖ Performance optimized with Core Web Vitals focus
‚úÖ SEO-ready for production deployment
‚úÖ Analytics and monitoring integration

DELIVERABLE: Production-ready web application with enterprise-quality user experience

BEGIN AUTONOMOUS WEB INTERFACE IMPLEMENTATION NOW.
```

---

## üñ•Ô∏è Phase 3: CLI Tool Subagent

**Copy this prompt exactly into Claude Code:**

```
FRAMEWORK-ENHANCED CLI SUBAGENT

<!-- MODEL_DIRECTIVE: Sonnet 4 throughout - standard CLI implementation -->
@model:sonnet-4

RATIONALE: CLI development follows established patterns. Commander.js, inquirer, and GitHub integration are standard implementations suitable for Sonnet 4.

You are an autonomous development subagent implementing Phase 3: CLI Tool with community framework patterns.

PROJECT CONTEXT:
- Building npm-publishable CLI tool integrating with evaluation engine
- Must work seamlessly with existing web interface
- Enhanced with api-builder and deployment-engineer patterns
- Target: Professional CLI tool ready for community distribution

FRAMEWORK-ENHANCED AUTONOMOUS EXECUTION:

1. **CLI Architecture Patterns**:
   - Professional command structure with help systems
   - Interactive prompts with validation and error recovery
   - GitHub integration with robust error handling

2. **Community Integration Patterns**:
   - Use api-builder patterns for GitHub API integration
   - Apply deployment-engineer patterns for cross-platform compatibility
   - Implement professional CLI UX patterns

3. **Distribution Readiness**:
   - npm package preparation and optimization
   - Cross-platform testing and validation
   - Professional documentation and examples

AUTONOMOUS EXECUTION WORKFLOW:
Read BUILD_PHASES.md Phase 3 (Steps 36-50), implement professional CLI tool with framework patterns, integrate with evaluation engine, prepare for npm distribution

SUCCESS CRITERIA:
‚úÖ Professional CLI tool with comprehensive command structure
‚úÖ GitHub integration with robust error handling
‚úÖ Cross-platform compatibility validated
‚úÖ npm package ready for publication
‚úÖ Comprehensive help system and documentation

DELIVERABLE: Production-ready CLI tool for community distribution

BEGIN AUTONOMOUS CLI IMPLEMENTATION NOW.
```

---

## üß™ Phase 4: Testing Subagent

**Copy this prompt exactly into Claude Code:**

```
FRAMEWORK-ENHANCED TESTING SUBAGENT

<!-- MODEL_DIRECTIVE: Sonnet 4 throughout - standard testing patterns -->
@model:sonnet-4

RATIONALE: Jest, React Testing Library, and E2E testing follow established patterns. Test generation and validation are routine tasks optimal for Sonnet 4.

You are an autonomous development subagent implementing Phase 4: Testing with comprehensive quality assurance patterns.

PROJECT CONTEXT:
- Building enterprise-level test suite for web + CLI components
- Must achieve 90%+ test coverage across all components
- Enhanced with test-automator and performance-engineer patterns
- Target: Production-ready quality assurance and performance validation

FRAMEWORK-ENHANCED AUTONOMOUS EXECUTION:

1. **Comprehensive Testing Strategy**:
   - Unit tests for all evaluation engine components
   - Integration tests for web interface user flows
   - E2E tests for complete evaluation journeys
   - CLI command testing and validation

2. **Performance and Quality Validation**:
   - Load testing and bottleneck identification
   - Performance benchmarking and optimization
   - Security vulnerability scanning

3. **Continuous Quality Assurance**:
   - GitHub Actions CI/CD integration
   - Quality gates and automated validation
   - Performance monitoring setup

AUTONOMOUS EXECUTION WORKFLOW:
Read BUILD_PHASES.md Phase 4 (Steps 51-70), implement comprehensive test suite with framework patterns, validate performance and security, setup continuous integration

SUCCESS CRITERIA:
‚úÖ 90%+ test coverage across all components
‚úÖ Complete E2E test suite for user journeys
‚úÖ Performance benchmarks and optimization
‚úÖ CI/CD pipeline with quality gates
‚úÖ Security validation and vulnerability scanning

DELIVERABLE: Enterprise-quality test suite with continuous integration

BEGIN AUTONOMOUS TESTING IMPLEMENTATION NOW.
```

---

## üöÄ Phase 5: Deployment Subagent

**Copy this prompt exactly into Claude Code:**

```
FRAMEWORK-ENHANCED DEPLOYMENT SUBAGENT

<!-- MODEL_DIRECTIVE: Sonnet 4 throughout - standard deployment procedures -->
@model:sonnet-4

RATIONALE: Vercel deployment, domain configuration, and CI/CD setup are standard DevOps tasks. Sonnet 4 handles these efficiently.

You are an autonomous development subagent implementing Phase 5: Deployment with enterprise deployment patterns.

PROJECT CONTEXT:
- Deploying to https://stack.organizedai.vip with Cloudflare integration
- Must setup production monitoring and analytics
- Enhanced with cloud-architect and deployment-engineer patterns
- Target: Production-ready deployment with monitoring and optimization

FRAMEWORK-ENHANCED AUTONOMOUS EXECUTION:

1. **Production Deployment Strategy**:
   - Vercel deployment with optimal configuration
   - Cloudflare domain integration and SSL setup
   - Environment variable and security configuration

2. **Monitoring and Analytics Integration**:
   - Production monitoring and alerting setup
   - Analytics integration for usage tracking
   - Performance monitoring and optimization

3. **Community and Growth Preparation**:
   - SEO optimization for discoverability
   - Social media and community engagement setup
   - Feedback systems and continuous improvement

AUTONOMOUS EXECUTION WORKFLOW:
Read BUILD_PHASES.md Phase 5 (Steps 71-80), deploy to production with framework patterns, setup monitoring and analytics, prepare for community launch

SUCCESS CRITERIA:
‚úÖ Production deployment at https://stack.organizedai.vip
‚úÖ Monitoring and analytics fully operational
‚úÖ SEO optimization and social media integration
‚úÖ Community feedback systems active
‚úÖ Performance optimization and scaling ready

DELIVERABLE: Live production system with monitoring and community engagement

BEGIN AUTONOMOUS DEPLOYMENT IMPLEMENTATION NOW.
```

---

## üìä Resource Optimization Summary

### Model Usage Strategy:
- **Opus 4 (3-4 hours total)**: Reserved for Phase 1 algorithm design only
- **Sonnet 4 (26-38 hours total)**: All other development tasks
- **Efficiency Gain**: 60-75% reduction in Opus 4 usage vs undifferentiated approach
- **Quality Maintained**: Complex tasks still receive premium intelligence
- **Capacity Preserved**: More Opus 4 hours available for other projects

### Expected Resource Usage:
- **Phase 1**: 1-2 Opus hours + 5-6 Sonnet hours = 6-8 total hours
- **Phase 2**: 8-11 Sonnet hours (UI/React development)
- **Phase 3**: 5-7 Sonnet hours (CLI implementation)
- **Phase 4**: 5-9 Sonnet hours (Testing and QA)
- **Phase 5**: 3-5 Sonnet hours (Deployment and monitoring)

**Total Project**: 3-4 Opus hours + 26-38 Sonnet hours = 29-42 total hours (21-30% of weekly capacity)

