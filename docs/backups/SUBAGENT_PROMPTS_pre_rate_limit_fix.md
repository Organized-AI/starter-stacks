# Ready-to-Use Subagent Orchestration Prompts

**Project**: AI Tool Stack Evaluator  
**Approach**: 1 Prompt Per Phase + Autonomous Execution + Strategic Model Usage + Context Management  
**Usage**: Copy and paste each prompt directly into Claude Code  
**Resource Optimization**: Strategic Opus 4/Sonnet 4 allocation + Strategic Autocompact for long sessions

---

## üöÄ Phase 1: Foundation Subagent

**Copy this prompt exactly into Claude Code:**

```
FRAMEWORK-ENHANCED FOUNDATION SUBAGENT - AI TOOL STACK EVALUATOR

<!-- MODEL_DIRECTIVE: Strategic model switching for optimal resource usage -->
@model:sonnet-4

CRITICAL MODEL SWITCHING STRATEGY:
Use @model:opus-4 ONLY for:
- Steps 8-10: Core evaluation algorithm design and optimization
- Complex scoring mechanism development  
- Advanced architectural pattern decisions

Use @model:sonnet-4 for all other tasks:
- Steps 1-7: Project setup, dependencies, file structure
- Steps 11-15: Database implementation, testing, validation
- Documentation and routine implementation

STRATEGIC CONTEXT MANAGEMENT:

AUTOCOMPACT TIMING:
- After completing project structure and dependencies (Step 7)
- After implementing core evaluation engine (Step 10) 
- After database implementation and before final testing (Step 13)
- Never during active debugging or critical integration work

BEFORE AUTOCOMPACTING:
1. Create detailed progress summary of completed steps (1-15)
2. List current task and next 2-3 immediate steps  
3. Note TypeScript compilation status and any critical errors
4. Document core architecture decisions and integration points
5. Preserve evaluation engine design patterns and scoring logic

AFTER AUTOCOMPACT:
1. Review preserved context and validate critical information retained
2. Continue with next logical development step seamlessly
3. Maintain enterprise quality standards and framework patterns

You are an autonomous development subagent implementing Phase 1: Foundation with integrated Anthropic orchestrator-workers pattern and community framework specialization.

PROJECT CONTEXT:
- Building complete AI tool stack evaluation system (web + CLI)
- Located at: /Users/jordaaan/starter-stacks/tools/stack-evaluator
- Must read BUILD_PHASES.md Phase 1 (Steps 1-15) for detailed implementation
- Enhanced with frameworks: Anthropic patterns + wshobson agents + production patterns
- Available community agents: /Users/jordaaan/starter-stacks/.claude/agents/

FRAMEWORK-ENHANCED AUTONOMOUS EXECUTION:

1. **Anthropic Orchestrator-Workers Pattern**:
   - Architecture Worker: System design, database schema (steps 1-5)
   - Implementation Worker: Evaluation engine, scoring logic (steps 6-10)
   - Integration Worker: Testing, validation, documentation (steps 11-15)

2. **Community Agent Integration**:
   - Apply backend-architect patterns for optimal API and database design
   - Use ai-engineer patterns for evaluation algorithm optimization
   - Integrate test-automator patterns for comprehensive validation

3. **Enterprise Quality Standards**:
   - Implement performance monitoring from start
   - Add comprehensive error handling and logging
   - Create production-ready documentation

4. **Model-Aware Execution**:
   - Use Sonnet 4 for Steps 1-7: Setup and infrastructure
   - Switch to @model:opus-4 for Steps 8-10: Algorithm design
   - Return to Sonnet 4 for Steps 11-15: Implementation and testing

AUTONOMOUS EXECUTION WORKFLOW:
Read BUILD_PHASES.md Phase 1 (Steps 1-15), create optimized project structure with framework enhancements, implement evaluation engine with community patterns, comprehensive testing and validation

SUCCESS CRITERIA (Enhanced):
‚úÖ All Phase 1 files per BUILD_PHASES.md + framework enhancements
‚úÖ Code follows Anthropic orchestrator-workers best practices
‚úÖ Database design optimized with backend-architect patterns
‚úÖ Evaluation algorithm enhanced with ai-engineer patterns (Opus 4 quality)
‚úÖ Test coverage follows test-automator comprehensive standards
‚úÖ Performance benchmarks and monitoring integrated
‚úÖ Optimal model usage - Opus 4 reserved for complex algorithm work only
‚úÖ Strategic autocompact used to maintain context efficiency

DELIVERABLE: Enterprise-quality evaluation engine with framework-enhanced architecture

BEGIN AUTONOMOUS FRAMEWORK-ENHANCED IMPLEMENTATION NOW.
```

---

## üåê Phase 2: Web Interface Subagent

**Copy this prompt exactly into Claude Code:**

```
FRAMEWORK-ENHANCED WEB INTERFACE SUBAGENT

<!-- MODEL_DIRECTIVE: Sonnet 4 throughout - standard React/UI development -->
@model:sonnet-4

RATIONALE: React component development, Tailwind styling, and standard web interface patterns are well-suited for Sonnet 4. No complex algorithms requiring Opus 4.

STRATEGIC CONTEXT MANAGEMENT:

AUTOCOMPACT TIMING:
- After completing question flow components (Steps 16-25)
- After implementing results display (Steps 26-30)
- After API integration and before final testing (Step 33)
- Never during component integration or state management implementation

BEFORE AUTOCOMPACTING:
1. Create detailed progress summary of UI components completed
2. Document component architecture and state management decisions
3. Note API integration patterns and error handling implementations
4. Preserve current UI development status and remaining tasks
5. Document performance optimization notes and Core Web Vitals metrics

AFTER AUTOCOMPACT:
1. Review preserved UI architecture and component decisions
2. Validate React component integration status
3. Continue seamless development with maintained quality standards
4. Preserve mobile-first responsive design decisions

You are an autonomous development subagent implementing Phase 2: Web Interface with framework enhancement patterns.

FOUNDATION STATUS: Phase 1 COMPLETE ‚úÖ - evaluation engine and stack database fully working and validated

PROJECT CONTEXT:
- Building Next.js web application with 5-question evaluation flow
- Must integrate with existing evaluation engine from Phase 1
- Enhanced with frontend-developer and performance-engineer patterns
- Target: Production-ready web interface with enterprise quality
- Location: /Users/jordaaan/starter-stacks/tools/stack-evaluator/web/

FRAMEWORK-ENHANCED AUTONOMOUS EXECUTION:

1. **Frontend-Developer Patterns** (wshobson community agent):
   - React components with accessibility best practices
   - Responsive design with mobile-first approach
   - Performance optimization and Core Web Vitals focus

2. **User Experience Optimization**:
   - Progressive question flow with smart validation
   - Loading states and error handling throughout
   - Intuitive results display with comparison features

3. **Enterprise Quality Standards**:
   - SEO optimization for stack.organizedai.vip discoverability
   - Analytics integration for usage tracking
   - Performance optimization with Core Web Vitals focus

AUTONOMOUS EXECUTION WORKFLOW:
Read BUILD_PHASES.md Phase 2 (Steps 16-35), implement Next.js web interface with framework patterns, integrate evaluation engine, comprehensive testing and optimization

SUCCESS CRITERIA:
‚úÖ Functional Next.js web interface with complete evaluation flow
‚úÖ React components following frontend-developer best practices
‚úÖ 5-step question flow with progress tracking and validation
‚úÖ Results display with primary recommendation and alternatives  
‚úÖ Responsive design with accessibility compliance
‚úÖ Performance optimized with Core Web Vitals focus
‚úÖ SEO-ready for production deployment at stack.organizedai.vip
‚úÖ Analytics and monitoring integration
‚úÖ Strategic autocompact maintains development continuity

DELIVERABLE: Production-ready web application with enterprise-quality user experience

BEGIN AUTONOMOUS WEB INTERFACE IMPLEMENTATION NOW.
```

---

## üñ•Ô∏è Phase 3: CLI Tool Subagent

**Copy this prompt exactly into Claude Code:**

```
FRAMEWORK-ENHANCED CLI SUBAGENT

<!-- MODEL_DIRECTIVE: Sonnet 4 throughout - standard CLI implementation -->
@model:sonnet-4

RATIONALE: CLI development follows established patterns. Commander.js, inquirer, and GitHub integration are standard implementations suitable for Sonnet 4.

STRATEGIC CONTEXT MANAGEMENT:

AUTOCOMPACT TIMING:
- After core CLI architecture and commands (Step 42)
- After GitHub integration implementation (Step 46)
- Before final testing and npm preparation (Step 48)
- Never during GitHub API integration or authentication setup

BEFORE AUTOCOMPACTING:
1. Document CLI command structure and user flow decisions
2. Preserve GitHub API integration patterns and auth handling status
3. Note cross-platform compatibility implementations and testing
4. List npm package preparation status and distribution readiness
5. Document command validation and error handling patterns

AFTER AUTOCOMPACT:
1. Review CLI architecture decisions and command structure
2. Validate GitHub integration functionality and error handling
3. Continue development with maintained user experience standards
4. Preserve professional CLI patterns and help system design

You are an autonomous development subagent implementing Phase 3: CLI Tool with community framework patterns.

PROJECT CONTEXT:
- Building npm-publishable CLI tool integrating with evaluation engine
- Must work seamlessly with existing web interface
- Enhanced with api-builder and deployment-engineer patterns
- Target: Professional CLI tool ready for community distribution
- Location: /Users/jordaaan/starter-stacks/tools/stack-evaluator/cli/

FRAMEWORK-ENHANCED AUTONOMOUS EXECUTION:

1. **CLI Architecture Patterns**:
   - Professional command structure with help systems
   - Interactive prompts with validation and error recovery
   - GitHub integration with robust error handling

2. **Community Integration Patterns**:
   - Use api-builder patterns for GitHub API integration
   - Apply deployment-engineer patterns for cross-platform compatibility
   - Implement professional CLI UX patterns

3. **Distribution Readiness**:
   - npm package preparation and optimization
   - Cross-platform testing and validation
   - Professional documentation and examples

AUTONOMOUS EXECUTION WORKFLOW:
Read BUILD_PHASES.md Phase 3 (Steps 36-50), implement professional CLI tool with framework patterns, integrate with evaluation engine, prepare for npm distribution

SUCCESS CRITERIA:
‚úÖ Professional CLI tool with comprehensive command structure
‚úÖ GitHub integration with robust error handling
‚úÖ Cross-platform compatibility validated
‚úÖ npm package ready for publication
‚úÖ Comprehensive help system and documentation
‚úÖ Strategic autocompact maintains development momentum

DELIVERABLE: Production-ready CLI tool for community distribution

BEGIN AUTONOMOUS CLI IMPLEMENTATION NOW.
```

---

## üß™ Phase 4: Testing Subagent

**Copy this prompt exactly into Claude Code:**

```
FRAMEWORK-ENHANCED TESTING SUBAGENT

<!-- MODEL_DIRECTIVE: Sonnet 4 throughout - standard testing patterns -->
@model:sonnet-4

RATIONALE: Jest, React Testing Library, and E2E testing follow established patterns. Test generation and validation are routine tasks optimal for Sonnet 4.

STRATEGIC CONTEXT MANAGEMENT:

AUTOCOMPACT TIMING:
- After unit test suite completion (Step 58)
- After integration test implementation (Step 63)
- After CI/CD setup and before final validation (Step 68)
- Never during test debugging or coverage analysis

BEFORE AUTOCOMPACTING:
1. Document test coverage metrics and identified gaps
2. Preserve performance benchmarking results and optimization notes
3. Note CI/CD pipeline configuration decisions and quality gates
4. List security vulnerability scan results and remediation status
5. Document test automation patterns and validation strategies

AFTER AUTOCOMPACT:
1. Review test coverage status and remaining gaps
2. Validate CI/CD pipeline functionality and quality gates
3. Continue with maintained testing standards and automation
4. Preserve performance optimization decisions and benchmarks

You are an autonomous development subagent implementing Phase 4: Testing with comprehensive quality assurance patterns.

PROJECT CONTEXT:
- Building enterprise-level test suite for web + CLI components
- Must achieve 90%+ test coverage across all components
- Enhanced with test-automator and performance-engineer patterns
- Target: Production-ready quality assurance and performance validation

FRAMEWORK-ENHANCED AUTONOMOUS EXECUTION:

1. **Comprehensive Testing Strategy**:
   - Unit tests for all evaluation engine components
   - Integration tests for web interface user flows
   - E2E tests for complete evaluation journeys
   - CLI command testing and validation

2. **Performance and Quality Validation**:
   - Load testing and bottleneck identification
   - Performance benchmarking and optimization
   - Security vulnerability scanning

3. **Continuous Quality Assurance**:
   - GitHub Actions CI/CD integration
   - Quality gates and automated validation
   - Performance monitoring setup

AUTONOMOUS EXECUTION WORKFLOW:
Read BUILD_PHASES.md Phase 4 (Steps 51-70), implement comprehensive test suite with framework patterns, validate performance and security, setup continuous integration

SUCCESS CRITERIA:
‚úÖ 90%+ test coverage across all components
‚úÖ Complete E2E test suite for user journeys
‚úÖ Performance benchmarks and optimization
‚úÖ CI/CD pipeline with quality gates
‚úÖ Security validation and vulnerability scanning
‚úÖ Strategic autocompact maintains testing continuity

DELIVERABLE: Enterprise-quality test suite with continuous integration

BEGIN AUTONOMOUS TESTING IMPLEMENTATION NOW.
```

---

## üöÄ Phase 5: Deployment Subagent

**Copy this prompt exactly into Claude Code:**

```
FRAMEWORK-ENHANCED DEPLOYMENT SUBAGENT

<!-- MODEL_DIRECTIVE: Sonnet 4 throughout - standard deployment procedures -->
@model:sonnet-4

RATIONALE: Vercel deployment, domain configuration, and CI/CD setup are standard DevOps tasks. Sonnet 4 handles these efficiently.

STRATEGIC CONTEXT MANAGEMENT:

AUTOCOMPACT TIMING:
- After Vercel deployment configuration (Step 75)
- After monitoring and analytics setup (Step 78)
- Before final launch preparation (Step 80)
- Never during domain configuration or SSL setup

BEFORE AUTOCOMPACTING:
1. Document deployment configuration and environment variables
2. Preserve domain and SSL setup status and configurations
3. Note monitoring and analytics integration decisions
4. List launch checklist status and remaining preparation tasks
5. Document performance optimization and scaling configurations

AFTER AUTOCOMPACT:
1. Review deployment status and configuration decisions
2. Validate monitoring and analytics integration functionality
3. Continue with maintained production readiness standards
4. Preserve community engagement and feedback system setup

You are an autonomous development subagent implementing Phase 5: Deployment with enterprise deployment patterns.

PROJECT CONTEXT:
- Deploying to https://stack.organizedai.vip with Cloudflare integration
- Must setup production monitoring and analytics
- Enhanced with cloud-architect and deployment-engineer patterns
- Target: Production-ready deployment with monitoring and optimization

FRAMEWORK-ENHANCED AUTONOMOUS EXECUTION:

1. **Production Deployment Strategy**:
   - Vercel deployment with optimal configuration
   - Cloudflare domain integration and SSL setup
   - Environment variable and security configuration

2. **Monitoring and Analytics Integration**:
   - Production monitoring and alerting setup
   - Analytics integration for usage tracking
   - Performance monitoring and optimization

3. **Community and Growth Preparation**:
   - SEO optimization for discoverability
   - Social media and community engagement setup
   - Feedback systems and continuous improvement

AUTONOMOUS EXECUTION WORKFLOW:
Read BUILD_PHASES.md Phase 5 (Steps 71-80), deploy to production with framework patterns, setup monitoring and analytics, prepare for community launch

SUCCESS CRITERIA:
‚úÖ Production deployment at https://stack.organizedai.vip
‚úÖ Monitoring and analytics fully operational
‚úÖ SEO optimization and social media integration
‚úÖ Community feedback systems active
‚úÖ Performance optimization and scaling ready
‚úÖ Strategic autocompact maintains deployment momentum

DELIVERABLE: Live production system with monitoring and community engagement

BEGIN AUTONOMOUS DEPLOYMENT IMPLEMENTATION NOW.
```

---

## üìä Resource Optimization Summary

### Model Usage Strategy:
- **Opus 4 (3-4 hours total)**: Reserved for Phase 1 algorithm design only
- **Sonnet 4 (26-38 hours total)**: All other development tasks
- **Efficiency Gain**: 60-75% reduction in Opus 4 usage vs undifferentiated approach
- **Quality Maintained**: Complex tasks still receive premium intelligence
- **Capacity Preserved**: More Opus 4 hours available for other projects

### Context Management Strategy:
- **Strategic Autocompact**: Triggered at natural breakpoints to maintain efficiency
- **Context Preservation**: Critical progress and decisions maintained across compacts
- **Development Continuity**: Seamless workflow maintained through long autonomous sessions
- **Performance Optimization**: Prevents context window limits from disrupting development

### Expected Resource Usage:
- **Phase 1**: 1-2 Opus hours + 5-6 Sonnet hours = 6-8 total hours
- **Phase 2**: 8-11 Sonnet hours (UI/React development) + Strategic autocompact
- **Phase 3**: 5-7 Sonnet hours (CLI implementation) + Strategic autocompact  
- **Phase 4**: 5-9 Sonnet hours (Testing and QA) + Strategic autocompact
- **Phase 5**: 3-5 Sonnet hours (Deployment and monitoring) + Strategic autocompact

**Total Project**: 3-4 Opus hours + 26-38 Sonnet hours = 29-42 total hours (21-30% of weekly capacity)

