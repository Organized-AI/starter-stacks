#!/usr/bin/env node

/**
 * Claude Code Action Log Generator
 * Generates comprehensive action logs with token tracking and cost analysis
 */

const fs = require('fs');
const path = require('path');

class ActionLogGenerator {
    constructor() {
        this.baseDir = path.resolve(__dirname, '../../../');
        this.logDir = path.join(__dirname, '../logs');
        this.currentSession = {
            startTime: new Date(),
            actions: [],
            totalTokens: 0,
            totalCost: 0,
            filesModified: new Set(),
            toolsUsed: new Map()
        };
        
        // Token costs per model (in dollars per 1K tokens)
        this.tokenCosts = {
            'claude-sonnet-4': 0.003,
            'claude-opus-4': 0.015,
            'claude-haiku-4': 0.0003
        };
    }

    /**
     * Log a Claude Code action
     */
    logAction(actionData) {
        const timestamp = new Date();
        const action = {
            timestamp: timestamp.toISOString(),
            timeString: timestamp.toLocaleTimeString(),
            tool: actionData.tool || 'Unknown',
            action: actionData.action || 'Unknown action',
            files: actionData.files || [],
            tokens: actionData.tokens || 0,
            model: actionData.model || 'claude-sonnet-4',
            result: actionData.result || 'Success',
            details: actionData.details || '',
            cost: this.calculateCost(actionData.tokens || 0, actionData.model || 'claude-sonnet-4')
        };

        this.currentSession.actions.push(action);
        this.currentSession.totalTokens += action.tokens;
        this.currentSession.totalCost += action.cost;
        
        // Track files and tools
        if (action.files && action.files.length > 0) {
            action.files.forEach(file => this.currentSession.filesModified.add(file));
        }
        
        const toolCount = this.currentSession.toolsUsed.get(action.tool) || 0;
        this.currentSession.toolsUsed.set(action.tool, toolCount + 1);

        return action;
    }

    /**
     * Calculate cost for tokens based on model
     */
    calculateCost(tokens, model) {
        const rate = this.tokenCosts[model] || this.tokenCosts['claude-sonnet-4'];
        return (tokens / 1000) * rate;
    }

    /**
     * Generate markdown report for current session
     */
    generateSessionReport() {
        const now = new Date();
        const dateStr = now.toISOString().split('T')[0];
        const sessionDuration = Math.round((now - this.currentSession.startTime) / 1000 / 60); // minutes
        
        const report = `# Claude Code Action Log - ${dateStr}

## Session Overview
- **Start Time**: ${this.currentSession.startTime.toLocaleString()}
- **End Time**: ${now.toLocaleString()}
- **Duration**: ${sessionDuration} minutes
- **Total Actions**: ${this.currentSession.actions.length}
- **Token Usage**: ${this.currentSession.totalTokens.toLocaleString()} tokens
- **Total Cost**: $${this.currentSession.totalCost.toFixed(4)}
- **Files Modified**: ${this.currentSession.filesModified.size}
- **Tools Used**: ${this.currentSession.toolsUsed.size}

## Resource Utilization

### Token Distribution by Model
${this.generateModelBreakdown()}

### Tool Usage Statistics
${this.generateToolBreakdown()}

### File Operations
${this.generateFileBreakdown()}

## Detailed Action Timeline

${this.generateActionTimeline()}

## Session Performance Metrics

- **Actions per minute**: ${(this.currentSession.actions.length / sessionDuration).toFixed(2)}
- **Tokens per action**: ${Math.round(this.currentSession.totalTokens / this.currentSession.actions.length)}
- **Cost per action**: $${(this.currentSession.totalCost / this.currentSession.actions.length).toFixed(4)}
- **Files per action**: ${(this.currentSession.filesModified.size / this.currentSession.actions.length).toFixed(2)}

## Quality Indicators

${this.generateQualityMetrics()}

---
*Generated by Claude Code Action Log Generator - ${now.toLocaleString()}*
*Session ID: ${this.generateSessionId()}*
`;

        return report;
    }

    /**
     * Generate model usage breakdown
     */
    generateModelBreakdown() {
        const modelStats = {};
        this.currentSession.actions.forEach(action => {
            if (!modelStats[action.model]) {
                modelStats[action.model] = { tokens: 0, cost: 0, actions: 0 };
            }
            modelStats[action.model].tokens += action.tokens;
            modelStats[action.model].cost += action.cost;
            modelStats[action.model].actions += 1;
        });

        let breakdown = '';
        Object.entries(modelStats).forEach(([model, stats]) => {
            const percentage = ((stats.tokens / this.currentSession.totalTokens) * 100).toFixed(1);
            breakdown += `- **${model}**: ${stats.tokens.toLocaleString()} tokens (${percentage}%) - $${stats.cost.toFixed(4)} - ${stats.actions} actions\n`;
        });

        return breakdown;
    }

    /**
     * Generate tool usage breakdown
     */
    generateToolBreakdown() {
        let breakdown = '';
        const sortedTools = Array.from(this.currentSession.toolsUsed.entries())
            .sort((a, b) => b[1] - a[1]);

        sortedTools.forEach(([tool, count]) => {
            const percentage = ((count / this.currentSession.actions.length) * 100).toFixed(1);
            breakdown += `- **${tool}**: ${count} uses (${percentage}%)\n`;
        });

        return breakdown;
    }

    /**
     * Generate file operations breakdown
     */
    generateFileBreakdown() {
        const fileArray = Array.from(this.currentSession.filesModified);
        if (fileArray.length === 0) {
            return '- No files modified in this session\n';
        }

        let breakdown = `**Modified Files (${fileArray.length} total):**\n`;
        fileArray.forEach(file => {
            breakdown += `- \`${file}\`\n`;
        });

        return breakdown;
    }

    /**
     * Generate detailed action timeline
     */
    generateActionTimeline() {
        let timeline = '';
        
        this.currentSession.actions.forEach((action, index) => {
            timeline += `### [${action.timeString}] Tool: ${action.tool}\n`;
            timeline += `- **Action**: ${action.action}\n`;
            
            if (action.files && action.files.length > 0) {
                timeline += `- **Files**: ${action.files.map(f => `\`${f}\``).join(', ')}\n`;
            }
            
            timeline += `- **Model**: ${action.model}\n`;
            timeline += `- **Tokens**: ~${action.tokens.toLocaleString()} tokens\n`;
            timeline += `- **Cost**: $${action.cost.toFixed(4)}\n`;
            timeline += `- **Result**: ${action.result}\n`;
            
            if (action.details) {
                timeline += `- **Details**: ${action.details}\n`;
            }
            
            timeline += '\n';
        });

        return timeline;
    }

    /**
     * Generate quality metrics
     */
    generateQualityMetrics() {
        const successfulActions = this.currentSession.actions.filter(a => a.result === 'Success').length;
        const successRate = ((successfulActions / this.currentSession.actions.length) * 100).toFixed(1);
        
        const metrics = `- **Success Rate**: ${successRate}% (${successfulActions}/${this.currentSession.actions.length})
- **Error Actions**: ${this.currentSession.actions.length - successfulActions}
- **Average Tokens per Success**: ${Math.round(this.currentSession.totalTokens / successfulActions)}
- **Efficiency Score**: ${this.calculateEfficiencyScore()}/10`;

        return metrics;
    }

    /**
     * Calculate efficiency score based on various factors
     */
    calculateEfficiencyScore() {
        const successRate = this.currentSession.actions.filter(a => a.result === 'Success').length / this.currentSession.actions.length;
        const tokenEfficiency = Math.min(1, 500 / (this.currentSession.totalTokens / this.currentSession.actions.length));
        const toolDiversity = Math.min(1, this.currentSession.toolsUsed.size / 5);
        
        const score = (successRate * 0.5 + tokenEfficiency * 0.3 + toolDiversity * 0.2) * 10;
        return Math.round(score * 10) / 10;
    }

    /**
     * Generate unique session ID
     */
    generateSessionId() {
        return `session_${this.currentSession.startTime.getTime()}_${Math.random().toString(36).substr(2, 9)}`;
    }

    /**
     * Save report to file
     */
    saveReport() {
        const report = this.generateSessionReport();
        const date = new Date().toISOString().split('T')[0];
        const filename = `CLAUDE_CODE_ACTION_LOG_${date}_${Date.now()}.md`;
        const filepath = path.join(this.logDir, filename);
        
        // Ensure log directory exists
        if (!fs.existsSync(this.logDir)) {
            fs.mkdirSync(this.logDir, { recursive: true });
        }
        
        fs.writeFileSync(filepath, report);
        return filepath;
    }

    /**
     * Quick log method for common actions
     */
    quickLog(tool, action, files = [], tokens = 0, model = 'claude-sonnet-4', result = 'Success') {
        return this.logAction({
            tool,
            action,
            files: Array.isArray(files) ? files : [files],
            tokens,
            model,
            result
        });
    }

    /**
     * End session and generate final report
     */
    endSession() {
        const reportPath = this.saveReport();
        const summary = {
            totalActions: this.currentSession.actions.length,
            totalTokens: this.currentSession.totalTokens,
            totalCost: this.currentSession.totalCost,
            filesModified: this.currentSession.filesModified.size,
            reportPath
        };
        
        // Reset session
        this.currentSession = {
            startTime: new Date(),
            actions: [],
            totalTokens: 0,
            totalCost: 0,
            filesModified: new Set(),
            toolsUsed: new Map()
        };
        
        return summary;
    }
}

// Export for use as module
module.exports = ActionLogGenerator;

// CLI usage
if (require.main === module) {
    const generator = new ActionLogGenerator();
    
    // Example usage
    generator.quickLog('Read', 'Read project configuration file', ['/path/to/config.json'], 150);
    generator.quickLog('Edit', 'Updated component styling', ['/path/to/component.tsx'], 300);
    generator.quickLog('Bash', 'Run test suite', [], 75);
    
    const summary = generator.endSession();
    console.log('Session ended. Report saved to:', summary.reportPath);
    console.log('Summary:', summary);
}